using System;
using System.Globalization;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SystemCommandLine.ConfigBinder.Generators;

[Generator]
public sealed class CommandLineOptionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = IdentifyMatchingClasses(context);

        context.RegisterSourceOutput(candidates, EmitAndReportDiagnostics);
    }

    /// <summary>
    ///     Converts a property name to a kebab-case option name prefixed with two dashes.
    /// </summary>
    /// <param name="propertyName">The name of the property to convert.</param>
    /// <returns>
    ///     A kebab-case string prefixed with "--" that represents the option name.
    ///     If <paramref name="propertyName" /> is <c>null</c> or empty, the same value is returned.
    /// </returns>
    internal static string GetOptionName(string propertyName)
    {
        if (string.IsNullOrEmpty(propertyName))
        {
            return propertyName;
        }

        var sb = new StringBuilder("--");
        for (var i = 0; i < propertyName.Length; i++)
        {
            if (i > 0 && char.IsUpper(propertyName[i]) && char.IsLower(propertyName[i - 1]))
            {
                sb.Append('-');
            }

            sb.Append(char.ToLowerInvariant(propertyName[i]));
        }

        return sb.ToString();
    }

    private static void Emit(SourceProductionContext ctx, Match m)
    {
        var nameSpace = m.OptionsClassSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : m.OptionsClassSymbol.ContainingNamespace.ToDisplayString();

        var sb = new StringBuilder();
        if (nameSpace is not null)
        {
            sb.AppendLine($"namespace {nameSpace};").AppendLine();
        }

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine($"partial class {m.OptionsClassSymbol.Name}");
        sb.AppendLine("{");

        var properties = m.TargetConfigSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.SetMethod is not null && p.DeclaredAccessibility == Accessibility.Public)
            .ToList();

        foreach (IPropertySymbol? propertySymbol in properties)
        {
            var optionName = GetOptionName(propertySymbol.Name);
            var optionFieldName = $"{propertySymbol.Name}Option";
            var optionTypeName = $"System.CommandLine.Option<{propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}>";
            var required = propertySymbol.Type.IsReferenceType && propertySymbol.NullableAnnotation != NullableAnnotation.Annotated;

            var defaultExpression = GetDefaultExpression(propertySymbol);
            sb.AppendLine($"    public static {optionTypeName} {optionFieldName} {{ get; }} = new(\"{optionName}\")");
            sb.AppendLine("    {");
            sb.AppendLine($"        Description = \"{propertySymbol.Name}.\",");
            if (required && defaultExpression is null)
            {
                sb.AppendLine("        Required = true,");
            }

            if (defaultExpression is not null)
            {
                sb.AppendLine("        Required = false,");
            }

            if (defaultExpression is not null)
            {
                sb.AppendLine($"        DefaultValueFactory = _ => {defaultExpression},");
            }

            sb.AppendLine("    };").AppendLine();
        }

        sb.AppendLine("    public static void AddOptionsTo(System.CommandLine.Command command)");
        sb.AppendLine("    {");
        foreach (IPropertySymbol? prop in properties)
        {
            sb.AppendLine($"        command.Options.Add({prop.Name}Option);");
        }

        sb.AppendLine("    }").AppendLine();

        sb.AppendLine($"    public static {m.TargetConfigSymbol.Name} Get(System.CommandLine.ParseResult parseResult)");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {m.TargetConfigSymbol.Name}");
        sb.AppendLine("        {");
        var separator = new StringBuilder(",").AppendLine().ToString();
        sb.AppendLine(string.Join(separator,
            properties.Select(p =>
            {
                var getter = $"parseResult.GetValue({p.Name}Option)";
                if (p.Type.SpecialType == SpecialType.System_String)
                {
                    getter += " ?? string.Empty";
                }

                return $"            {p.Name} = {getter}";
            })));
        sb.AppendLine("        };");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        ctx.AddSource($"{m.OptionsClassSymbol.Name}.CommandLineOptions.g.cs", sb.ToString());
    }

    private static void EmitAndReportDiagnostics(SourceProductionContext sourceProductionContext, Match match)
    {
        try
        {
            Emit(sourceProductionContext, match);
        }
        catch (Exception ex)
        {
            sourceProductionContext.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("SCB001",
                    "ConfigBinder generation error",
                    "Failed generating options for {0}: {1}",
                    "ConfigBinder",
                    DiagnosticSeverity.Warning,
                    true),
                Location.None,
                match.OptionsClassSymbol.Name,
                ex.Message));
        }
    }

    private static string? GetDefaultExpression(IPropertySymbol prop)
    {
        SyntaxReference? syntaxReference = prop.DeclaringSyntaxReferences.FirstOrDefault();
        var propertyDeclaration = syntaxReference?.GetSyntax() as PropertyDeclarationSyntax;
        if (propertyDeclaration?.Initializer?.Value is LiteralExpressionSyntax literal)
        {
            return Literal(literal);
        }

        return null;
    }

    private static Match? GetMatch(GeneratorSyntaxContext ctx)
    {
        var classSyntax = (ClassDeclarationSyntax)ctx.Node;
        INamedTypeSymbol? symbol = ctx.SemanticModel.GetDeclaredSymbol(classSyntax);
        if (symbol is null)
        {
            return null;
        }

        // Find the CommandLineOptionsFor attribute in the syntax
        AttributeSyntax? attributeSyntax = classSyntax.AttributeLists.SelectMany(al => al.Attributes)
            .FirstOrDefault(a => a.Name.ToString().Contains("CommandLineOptionsFor") || a.Name.ToString() == "CommandLineOptionsFor");

        // Parse the typeof(Type) argument from the syntax
        AttributeArgumentSyntax? firstArg = attributeSyntax?.ArgumentList?.Arguments.FirstOrDefault();
        if (firstArg?.Expression is not TypeOfExpressionSyntax typeofExpr)
        {
            return null;
        }

        // Get the type symbol from the typeof expression
        TypeInfo targetTypeInfo = ctx.SemanticModel.GetTypeInfo(typeofExpr.Type);
        return targetTypeInfo.Type is INamedTypeSymbol targetType ? new Match(symbol, targetType) : null;
    }

    private static IncrementalValuesProvider<Match> IdentifyMatchingClasses(IncrementalGeneratorInitializationContext context)
    {
        return context.SyntaxProvider
            .CreateSyntaxProvider((node, _) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 }, (ctx, _) => GetMatch(ctx))
            .Where(static m => m is not null)
            .Select((m, _) => m!);
    }

    private static string Literal(object? v)
    {
        return v switch
        {
            null => "null",
            string s => new StringBuilder().Append('"').Append(s.Replace(@"""", @"\""")).Append('"').ToString(),
            bool b => b ? "true" : "false",
            char c => new StringBuilder("'").Append(c == '\'' ? "\\'" : c).Append("'").ToString(),
            _ => Convert.ToString(v, CultureInfo.InvariantCulture) ?? "null"
        };
    }

    private sealed record Match(INamedTypeSymbol OptionsClassSymbol, INamedTypeSymbol TargetConfigSymbol)
    {
        public INamedTypeSymbol OptionsClassSymbol { get; } = OptionsClassSymbol;
        public INamedTypeSymbol TargetConfigSymbol { get; } = TargetConfigSymbol;
    }
}