using System;
using System.Globalization;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SystemCommandLine.ConfigBinder.Generators;

[Generator] public sealed class CommandLineOptionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = IdentifyMatchingClasses(context);

        context.RegisterSourceOutput(candidates, EmitAndReportDiagnostics);
    }

    internal static string EscapeString(string input)
    {
        return input.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\r", "\\r").Replace("\n", "\\n");
    }

    /// <summary>
    ///     Converts a property name to a kebab-case option name prefixed with two dashes.
    /// </summary>
    /// <param name="propertyName">The name of the property to convert.</param>
    /// <returns>
    ///     A kebab-case string prefixed with "--" that represents the option name.
    ///     If <paramref name="propertyName" /> is <c>null</c> or empty, the same value is returned.
    /// </returns>
    internal static string GetOptionName(string propertyName)
    {
        if (string.IsNullOrEmpty(propertyName))
        {
            return propertyName;
        }

        var sb = new StringBuilder("--");
        for (var i = 0; i < propertyName.Length; i++)
        {
            if (i > 0 && char.IsUpper(propertyName[i]) && char.IsLower(propertyName[i - 1]))
            {
                sb.Append('-');
            }

            sb.Append(char.ToLowerInvariant(propertyName[i]));
        }

        return sb.ToString();
    }

    private static void Emit(SourceProductionContext ctx, Match m)
    {
        var nameSpace = m.OptionsClassSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : m.OptionsClassSymbol.ContainingNamespace.ToDisplayString();

        var sb = new StringBuilder();
        if (nameSpace is not null)
        {
            sb.AppendLine($"namespace {nameSpace};").AppendLine();
        }

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine($"partial class {m.OptionsClassSymbol.Name}");
        sb.AppendLine("{");
        sb.AppendLine($"    private {m.OptionsClassSymbol.Name}() {{ }}").AppendLine();

        var properties = m.TargetConfigSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.SetMethod is not null && p.DeclaredAccessibility == Accessibility.Public)
            .ToList();

        foreach (IPropertySymbol? propertySymbol in properties)
        {
            var optionName = GetOptionName(propertySymbol.Name);
            var optionFieldName = $"{propertySymbol.Name}Option";
            var optionTypeName = $"System.CommandLine.Option<{propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}>";
            var required = IsRequired(propertySymbol);

            var description = GetDescription(propertySymbol);
            var defaultExpression = GetDefaultExpression(propertySymbol);

            sb.AppendLine($"    public static {optionTypeName} {optionFieldName} {{ get; }} = new(\"{optionName}\")");
            sb.AppendLine("    {");
            sb.AppendLine($"        Description = \"{EscapeString(description)}\",");
            if (required)
            {
                sb.AppendLine("        Required = true");
            }
            else if (DefaultValueAnalyzer.ShouldApplyDefault(propertySymbol, defaultExpression))
            {
                sb.AppendLine($"        DefaultValueFactory = _ => {defaultExpression}");
            }

            sb.AppendLine("    };").AppendLine();
        }

        sb.AppendLine("    public static void AddOptionsTo(System.CommandLine.Command command)");
        sb.AppendLine("    {");
        foreach (IPropertySymbol? prop in properties)
        {
            sb.AppendLine($"        command.Options.Add({prop.Name}Option);");
        }

        sb.AppendLine("    }").AppendLine();

        sb.AppendLine($"    public static {m.TargetConfigSymbol.Name} Get(System.CommandLine.ParseResult parseResult)");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {m.TargetConfigSymbol.Name}");
        sb.AppendLine("        {");
        var separator = new StringBuilder(",").AppendLine().ToString();
        sb.AppendLine(string.Join(separator,
            properties.Select(p =>
            {
                var getter = $"parseResult.GetValue({p.Name}Option)";
                if (p.Type.SpecialType == SpecialType.System_String && p.NullableAnnotation != NullableAnnotation.Annotated)
                {
                    getter += " ?? string.Empty";
                }

                return $"            {p.Name} = {getter}";
            })));
        sb.AppendLine("        };");
        sb.AppendLine("    }");

        sb.AppendLine("}");

        ctx.AddSource($"{m.OptionsClassSymbol.Name}.CommandLineOptions.g.cs", sb.ToString());
    }

    private static void EmitAndReportDiagnostics(SourceProductionContext sourceProductionContext, Match match)
    {
        try
        {
            Emit(sourceProductionContext, match);
        }
        catch (Exception ex)
        {
            sourceProductionContext.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor("SCB001",
                    "ConfigBinder generation error",
                    "Failed generating options for {0}: {1}",
                    "ConfigBinder",
                    DiagnosticSeverity.Warning,
                    true),
                Location.None,
                match.OptionsClassSymbol.Name,
                ex.Message));
        }
    }

    private static string? GetDefaultExpression(IPropertySymbol prop)
    {
        SyntaxReference? syntaxReference = prop.DeclaringSyntaxReferences.FirstOrDefault();
        var propertyDeclaration = syntaxReference?.GetSyntax() as PropertyDeclarationSyntax;
        ExpressionSyntax? initializerValue = propertyDeclaration?.Initializer?.Value;

        if (initializerValue == null)
        {
            return null;
        }

        return initializerValue switch
        {
            LiteralExpressionSyntax literal => Literal(literal),
            MemberAccessExpressionSyntax memberAccess => GetEnumMemberExpression(memberAccess, prop),
            IdentifierNameSyntax identifier => GetIdentifierExpression(identifier, prop),
            _ => null
        };
    }

    private static string GetDescription(IPropertySymbol propertySymbol)
    {
        foreach (var namedArgument in propertySymbol.GetAttributes()
                     .Where(attribute => attribute.AttributeClass?.Name is "Display" or "DisplayAttribute")
                     .SelectMany(attribute => attribute.NamedArguments))
        {
            if (namedArgument is { Key: "Description", Value.Value: string description })
            {
                return description;
            }
        }

        return $"Sets the {propertySymbol.Name} value.";
    }

    private static string? GetEnumMemberExpression(MemberAccessExpressionSyntax memberAccess, IPropertySymbol prop)
    {
        if (prop.Type.TypeKind != TypeKind.Enum)
        {
            return null;
        }

        var enumTypeName = prop.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var memberName = memberAccess.Name.Identifier.ValueText;
        return $"{enumTypeName}.{memberName}";
    }

    private static string? GetIdentifierExpression(IdentifierNameSyntax identifier, IPropertySymbol prop)
    {
        if (prop.Type.TypeKind != TypeKind.Enum)
        {
            return null;
        }

        var enumTypeName = prop.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var memberName = identifier.Identifier.ValueText;
        return $"{enumTypeName}.{memberName}";
    }

    private static Match? GetMatch(GeneratorSyntaxContext ctx)
    {
        var classSyntax = (ClassDeclarationSyntax)ctx.Node;
        INamedTypeSymbol? symbol = ctx.SemanticModel.GetDeclaredSymbol(classSyntax);
        if (symbol is null)
        {
            return null;
        }

        // Find the CommandLineOptionsFor attribute in the syntax
        AttributeSyntax? attributeSyntax = classSyntax.AttributeLists.SelectMany(al => al.Attributes)
            .FirstOrDefault(a => a.Name.ToString().Contains("CommandLineOptionsFor"));

        // Parse the typeof(Type) argument from the syntax
        AttributeArgumentSyntax? firstArgument = attributeSyntax?.ArgumentList?.Arguments.FirstOrDefault();
        if (firstArgument?.Expression is not TypeOfExpressionSyntax typeOfExpressionSyntax)
        {
            return null;
        }

        // Get the type symbol from the typeof expression
        TypeInfo targetTypeInfo = ctx.SemanticModel.GetTypeInfo(typeOfExpressionSyntax.Type);
        return targetTypeInfo.Type is INamedTypeSymbol targetType ? new Match(symbol, targetType) : null;
    }

    private static IncrementalValuesProvider<Match> IdentifyMatchingClasses(IncrementalGeneratorInitializationContext context)
    {
        return context.SyntaxProvider
            .CreateSyntaxProvider((node, _) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 }, (ctx, _) => GetMatch(ctx))
            .Where(static m => m is not null)
            .Select((m, _) => m!);
    }

    private static bool IsRequired(IPropertySymbol propertySymbol)
    {
        return propertySymbol.GetAttributes().Any(a => a.AttributeClass?.Name is "Required" or "RequiredAttribute");
    }

    private static string Literal(object? obj)
    {
        return obj switch
        {
            null => "null",
            string s => new StringBuilder().Append('"').Append(s.Replace(@"""", @"\""")).Append('"').ToString(),
            bool b => b ? "true" : "false",
            char c => new StringBuilder("'").Append(c == '\'' ? "\\'" : c).Append("'").ToString(),
            _ => Convert.ToString(obj, CultureInfo.InvariantCulture) ?? "null"
        };
    }

    private sealed record Match(INamedTypeSymbol OptionsClassSymbol, INamedTypeSymbol TargetConfigSymbol)
    {
        public INamedTypeSymbol OptionsClassSymbol { get; } = OptionsClassSymbol;
        public INamedTypeSymbol TargetConfigSymbol { get; } = TargetConfigSymbol;
    }
}